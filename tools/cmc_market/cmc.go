package main

import (
	"encoding/json"
	"fmt"
	"github.com/astaxie/beego"
	"github.com/astaxie/beego/httplib"
	"github.com/vntchain/vnt-explorer/common"
	"github.com/vntchain/vnt-explorer/models"
	"io/ioutil"
	"net/http"
	"net/url"
	"strconv"
	"time"
)

var apikey = beego.AppConfig.String("market::apikey")

type AutoGenerated struct {
	Status Status `json:"status"`
	Data   Data   `json:"data"`
}
type Status struct {
	Timestamp    time.Time   `json:"timestamp"`
	ErrorCode    int         `json:"error_code"`
	ErrorMessage interface{} `json:"error_message"`
	Elapsed      int         `json:"elapsed"`
	CreditCount  int         `json:"credit_count"`
	Notice       interface{} `json:"notice"`
}
type Platform struct {
	ID           int    `json:"id"`
	Name         string `json:"name"`
	Symbol       string `json:"symbol"`
	Slug         string `json:"slug"`
	TokenAddress string `json:"token_address"`
}
type USD struct {
	Price            float64   `json:"price"`
	Volume24H        float64   `json:"volume_24h"`
	PercentChange1H  float64   `json:"percent_change_1h"`
	PercentChange24H float64   `json:"percent_change_24h"`
	PercentChange7D  float64   `json:"percent_change_7d"`
	MarketCap        float64   `json:"market_cap"`
	LastUpdated      time.Time `json:"last_updated"`
}
type Quote struct {
	USD USD `json:"USD"`
}
type VNT struct {
	ID                int           `json:"id"`
	Name              string        `json:"name"`
	Symbol            string        `json:"symbol"`
	Slug              string        `json:"slug"`
	NumMarketPairs    int           `json:"num_market_pairs"`
	DateAdded         time.Time     `json:"date_added"`
	Tags              []interface{} `json:"tags"`
	MaxSupply         interface{}   `json:"max_supply"`
	CirculatingSupply float64       `json:"circulating_supply"`
	TotalSupply       int64         `json:"total_supply"`
	Platform          Platform      `json:"platform"`
	CmcRank           int           `json:"cmc_rank"`
	LastUpdated       time.Time     `json:"last_updated"`
	Quote             Quote         `json:"quote"`
}
type Data struct {
	VNT VNT `json:"VNT"`
}

func UpdateCoinMarketToDB() {
	client := &http.Client{
		Transport: &http.Transport{
			Dial: httplib.TimeoutDialer(5 * time.Second, 5 * time.Second),
			DisableKeepAlives:true,
			MaxIdleConns:10,
			MaxConnsPerHost:10,
		},
	}
	req, err := http.NewRequest("GET","https://pro-api.coinmarketcap.com/v1/cryptocurrency/quotes/latest", nil)
	if err != nil {
		beego.Error("Get latest info from cmc failed ",err)
		return
	}
	q := url.Values{}
	q.Add("symbol", "VNT")
	q.Add("convert", "USD")
	req.Header.Set("Accepts", "application/json")
	req.Header.Add("X-CMC_PRO_API_KEY", apikey)
	req.URL.RawQuery = q.Encode()

	resp, err := client.Do(req);
	if err != nil {
		beego.Error("Error sending request to server")
		return
	}
	defer resp.Body.Close()
	if resp.Status == "200 OK" {
		respBody, _ := ioutil.ReadAll(resp.Body)
		beego.Debug(string(respBody));
		var res AutoGenerated
		if err = json.Unmarshal(respBody, &res); err != nil {
			beego.Error("json unmarshal err: ", err)
			return
		}
		if res.Status.ErrorCode != 0 {
			beego.Error("Get resp from cmc failed, Status.ErrorCode ", res.Status.ErrorCode)
			return
		}

		exRate, err:= GetExchangeRate()
		if err != nil {
			beego.Error("Get exchange rate failed, err ", err)
			exRate = 7.0
		}
		coin := models.MarketInfo{
			LastUpdated:      res.Data.VNT.LastUpdated.Unix(),
			PriceCny:         Decimal4(res.Data.VNT.Quote.USD.Price * exRate),
			PriceUsd:         Decimal4(res.Data.VNT.Quote.USD.Price),
			AvailableSupply:  float64(int(res.Data.VNT.CirculatingSupply)),
			Volume24h:        Decimal4(res.Data.VNT.Quote.USD.Volume24H), // ???
			Volume24hCny:     Decimal4(res.Data.VNT.Quote.USD.Volume24H * exRate),
			Volume24hUsd:     Decimal4(res.Data.VNT.Quote.USD.Volume24H),
			MarketCapCny:     res.Data.VNT.Quote.USD.MarketCap * exRate,
			MarketCapUsd:     res.Data.VNT.Quote.USD.MarketCap,
			PercentChange24h: Decimal2(res.Data.VNT.Quote.USD.PercentChange24H),
		}
		coin.Insert()

	} else {
		beego.Error("Get resp status not ok, status = ", resp.Status)
	}
	return
}

func Decimal4(value float64) float64 {
	value, _ = strconv.ParseFloat(fmt.Sprintf("%.4f", value), 64)
	return value
}
func Decimal2(value float64) float64 {
	value, _ = strconv.ParseFloat(fmt.Sprintf("%.2f", value), 64)
	return value
}

// 实时获取汇率
type exchangeRate struct {
	BankName string `json:"bankName"`
	Date     string `json:"date"`
	FSellPri string `json:"fSellPri"`
}
type rateData struct {
	Result []*exchangeRate
}

func GetExchangeRate() (float64, error) {
	url := "http://apicloud.mob.com/exchange/rmbquot/query?key=2970534a3dbfe&bank=1"
	client := &http.Client{
		Transport: &http.Transport{
			Dial: httplib.TimeoutDialer(5 * time.Second, 5 * time.Second),
			DisableKeepAlives:true,
			MaxIdleConns:10,
			MaxConnsPerHost:10,
		},
	}
	req, err := http.NewRequest("GET",url, nil)
	if err != nil {
		beego.Error("Get exchange rate info for cmc failed ",err)
		return 0.0, err
	}
	resp, err := client.Do(req);
	if err != nil {
		beego.Error("Error sending request to server in cmc")
		return 0.0, err
	}
	defer resp.Body.Close()

	respByte, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		beego.Error("Get resp body failed in cmc, err ", err)
		return 0.0, err
	}
	str := string(respByte)

	var data *rateData
	if err = json.Unmarshal([]byte(str), &data); err != nil {
		beego.Error(err)
		return 0.0, err
	}
	a := data.Result[0].FSellPri
	ret, err := strconv.ParseFloat(a, 64)
	if err == nil {
		return ret/100, nil
	} else {
		return 0.0, nil
	}

}

// one api key, just can be used to access 300 time for free
// so update the new data every 5min
func main() {
	common.InitLogLevel()
	go UpdateCoinMarketToDB()
	t := time.Tick(time.Minute * 5)
	for range t {
		go UpdateCoinMarketToDB()
	}
}
